<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroides</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>
</head>
<body>
    <canvas id="myCanvas">Your browser does not support the HTML5 canvas tag. </canvas>
	<div class="menu">
		<h1>Asteroides</h1>
		<button id="btn">Play</button>
		<button id="btnclose">Quit</button>
	</div>
    <div class="submenuinfo" style="visibility:hidden">
        <span> Press ESC to close or Press R to restart </span>
    </div>
    <div class="submenupoints" style="visibility:hidden">
        <span> <i class="fas fa-heart"></i> <span id="lifes"> 0 </span></span>
        <span> <i class="fas fa-trophy"></i> <span id="points"> 0 </span></span>
    </div>
	<script>
		var canvas = document.getElementById('myCanvas')
        //set canvas in full page
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight
		var ctx = canvas.getContext('2d');
		const W = canvas.width;
        const H = canvas.height;
		let img = new Image();
		img.src = 'https://i.ytimg.com/vi/y2_2Lcl5Iow/maxresdefault.jpg';
		ctx.drawImage(img, 0, 0,W,H);
        //set keys value
        let rightKey = false, leftKey = false, upKey = false, downKey = false, spaceKey=false;
        //position nav
        let xNav=0, yNav=0
        //load page
		class Asteroides {
            constructor(x, y, r, d, c) { // CONSTRUCTOR
                this.x = x; // initial X position
                this.y = y; // initial Y position
                if(r=="60"){
                     // (constant) horizontal displacement(velocity): d is a direction angle
                    this.dX = 2 * Math.cos(d);
                    // (constant) vertical displacement (velocity): d is a direction angle
                    this.dY = 2 * Math.sin(d);
                }
                else{
                     // (constant) horizontal displacement(velocity): d is a direction angle
                    this.dX = 5 * Math.cos(d);
                    // (constant) vertical displacement (velocity): d is a direction angle
                    this.dY = 5 * Math.sin(d);
                }
               
                this.c = c; // color
                this.R = r; // circle radius(constant)
            }

            draw() {
                ctx.strokeStyle = this.c;
                var numberOfSides = 8;
                var angle = 2 * Math.PI / numberOfSides;
                ctx.save()
                ctx.beginPath();
                ctx.translate(this.x, this.y);
                //rotation of asteroides
                if(this.R=="60"){
                    ctx.rotate(angleS * Math.PI / 180)
                }
                else{
                    ctx.rotate(angleS*Math.PI/40)
                }
                
                ctx.moveTo(this.R, 0);
                for (var i = 1; i <= numberOfSides; i++) {
                    ctx.lineTo(this.R * Math.cos(i * angle), this.R * Math.sin(i * angle));
                }
                ctx.lineWidth = 3
                ctx.stroke()
                ctx.restore()
            }

            update() {
               // check Canvas vertical collisions
                if (this.x < -this.R)
                    this.x = W + this.R;

                if (this.x > W + this.R)
                    this.x = -this.R;

                // check Canvas horizontal collisions
                if (this.y < -this.R)
                    this.y = H + this.R;

                if (this.y > H + this.R)
                    this.y = -this.R;

                this.x += this.dX; // update horizontal position
                this.y += this.dY; // update vertical position

            }
        }
        class Nav{
            constructor(x,y,r,c){
                this.x=x;
                this.y=y;
                this.r=r;
                this.c=c;

            }
            drawN() {
                ctx.strokeStyle = this.c;
                var numberOfSidesNav = 3;
		        var angleNav = 4*Math.PI/numberOfSidesNav;
                ctx.save()
                ctx.beginPath();
                ctx.translate(this.x, this.y);
                ctx.rotate(angleSNav * Math.PI / 180)
		        ctx.moveTo(0, -this.r);          
		        ctx.lineTo(this.r*Math.cos(1 * Math.PI/3), this.r*Math.sin(1 * Math.PI/3));
		        ctx.lineTo(this.r*Math.cos(2 * Math.PI/3), this.r*Math.sin(2 * Math.PI/3));
                ctx.closePath();
                ctx.lineWidth = 3
 		        ctx.stroke();
                ctx.restore()
                xNav=this.x
                yNav=this.y
            }
            updateN(){
                //update position
                if (rightKey && this.x + this.r < W)
                angleSNav++ ;
                if (leftKey && this.x - this.r > -this.r)
                angleSNav--;
                if (upKey )
                {
                    this.x += 4 * Math.cos(angleSNav* Math.PI / 180 - Math.PI/2)
                    this.y += 4 * Math.sin(angleSNav* Math.PI / 180 - Math.PI/2)
                    xNav=this.x
                    yNav=this.y
                }
            }

        }
        class Bullets{
            constructor(x,y,r,d){
                this.x=x;
                this.y=y;
                this.dX=4 * Math.cos(d - Math.PI/2)
                this.dY=4 * Math.sin(d - Math.PI/2)
                this.c='orange'
                this.r=r
            }
            drawB(){
                ctx.fillStyle=this.c
                ctx.beginPath()
                ctx.arc(this.x,this.y, this.r, 0, 2 * Math.PI)
                ctx.fill();
            }
            updateB(){
                if(this.x<-this.r)
                    b=b.filter(ball=>ball.x!=this.x);
                if (this.x > W + this.r)
                    b=b.filter(ball=>ball.x!=this.x);

                // check Canvas horizontal collisions
                if (this.y < -this.r)
                    b=b.filter(ball=>ball.x!=this.x);
                if (this.y > H + this.r)
                    b=b.filter(ball=>ball.x!=this.x);

                this.x += this.dX; // update horizontal position
                this.y += this.dY; // update vertical position

            }
        }
        let a = new Array();
        let n= new Array();
        let b=new Array();
        let stopGame=false
        let list = [60, 30] 
        for (let i = 0; i < 25; i++) {
            let x = Math.floor(Math.random() * (1 - 0 + 1)) + 0;
            let radius = list[x]
            let color = `white`;
            // randomposition (inside Canvas)
            let xInit = 20 + Math.random() * (W - 2 * 20);
            let yInit = 20 + Math.random() * (H - 2 * 20);
            // randomdirection
            let direction = Math.random() * 2 * Math.PI;
            a.push(new Asteroides(xInit, yInit, radius, direction, color))
        }
        let angleS=0
        let angleSNav=0
        function render() {
            // fade Canvas
			ctx.fillStyle="transparent"
            ctx.drawImage(img, 0, 0,W,H);
            ctx.fillRect(0, 0, W, H);
            checkCollisions();
            checkCollisionsShot();
            // draw & update
            a.forEach(asteroide => {
                asteroide.draw();
                asteroide.update();
            });

            n.forEach(nav => {
                nav.drawN();
                nav.updateN();
            });
            b.forEach(bullet => {
                bullet.drawB();
                bullet.updateB();
            });
            
            angleS++;
            //new frame
            if (stopGame==false){
            window.requestAnimationFrame(render);
            }
            else{
                ctx.fillStyle = "white";
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = 'bold 40px arial';
                ctx.fillText("YOU LOST!!", W / 2, H / 2);
            }
        }
        render(); //startthe animation
        
        //listen events of menu
		let btn=document.querySelector("#btn")
		btn.addEventListener("click",function(){
			startGame()
		}) 
        let btnClose=document.querySelector("#btnclose")
        btnClose.addEventListener("click",function(){
            window.open("", '_self').window.close();
        }) 
        //startGame
         // on key DOWN, check if it is an arrow, and signal the corresponding flag
        function startGame(){
            let menu=document.querySelector(".menu")
            menu.style.visibility='hidden'
            let submenuinfo=document.querySelector(".submenuinfo")
            submenuinfo.style.visibility='visible'
            let submenupoints=document.querySelector(".submenupoints")
            submenupoints.style.visibility='visible'
            let lifes=document.querySelector("#lifes")
            let points=document.querySelector("#points")
            lifes.innerHTML=2
            //set events for keys
            window.addEventListener('keydown', e => {
            if (e.key == 'ArrowRight')
                rightKey = true;
            if (e.key == 'ArrowLeft')
                leftKey = true;

            if (e.key == 'ArrowDown')
                downKey = true;
            if (e.key == 'ArrowUp')
                upKey = true;
            if (e.key == ' ')
                createBullet()
            if (e.key=='r')
                lifes.innerHTML=2,points.innerHTML=0,n=[],b=[],a=[],startGame();
            if (e.key=="Escape")
                location.reload()
            e.preventDefault();
            });

            // on key UP, check if it is an arrow, and signal the corresponding flag
            window.addEventListener('keyup', e => {
            if (e.key == 'ArrowRight')
                rightKey = false;
            if (e.key == 'ArrowLeft')
                leftKey = false;

            if (e.key == 'ArrowDown')
                downKey = false;
            if (e.key == 'ArrowUp')
                upKey = false;
            });
            //set asteroides
            a=new Array
            let list = [60, 30]
            angleS=0
            n.push(new Nav (W/2,H/2,30,'orange'))

            function createAsteroides(){ 
                for (let i = 0; i < 5; i++) {
                let x = Math.floor(Math.random() * (1 - 0 + 1)) + 0;
                let radius = list[x]
                let color = `white`;
                // randomposition (inside Canvas)
                let xInit = 20 + Math.random() * (W - 2 * 20);
                let yInit = 20 + Math.random() * (H - 2 * 20);
                while(xInit==xNav && yInit==yNav){
                    xInit=20 + Math.random() * (W - 2 * 20);
                    yInit = 20 + Math.random() * (H - 2 * 20);

                }
                // randomdirection
                let direction = Math.random() * 2 * Math.PI;
                a.push(new Asteroides(xInit, yInit, radius, direction, color))
                }
            }
            createAsteroides()
            setInterval(createAsteroides,20000)
        }
        function checkCollision(a, n) {
        // verifica colisão entre 1 inimigo e 1 bala
        var dx = (a.x + a.R) - (n.x + n.r);
        var dy = (a.y + a.R) - (n.y + n.r);
        var distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < a.R + n.r) {
            return true;
        }
        else{
            return false;
        }
    }

        function checkCollisions() {
            //percorre o array de inimigos 
            for (let i = 0; i < a.length; i++) {
                //percorre o array de balas 
                for (let j = 0; j <n.length; j++)
                    //verifica se há colisão entre dois objetos (1 inimigo e 1 bala)
                    if (checkCollision(a[i], n[j])) {
                        //sinaliza futura remoção da bala
                        lifes.innerHTML-=1
                        if(lifes.innerHTML=="1"){
                            a[i].dX=-a[i].dX
                            a[i].dY=-a[i].dY
                            n=[]
                            setTimeout(n.push(new Nav (W/2,H/2,30,'orange')),40000)
                        }
                        else if(lifes.innerHTML=="0"){
                        stopGame=true
                        n=[]
                        }
                    }
            }
        }
        function createBullet(){
            let xBullet=n[0].x
            let yBullet=n[0].y
            let radiusBullet=5
            let directionBullet = angleSNav * Math.PI / 180;
            xBullet += Math.cos(directionBullet - Math.PI/2) *30
            yBullet += Math.sin(directionBullet- Math.PI/2) *30
            //console.log(directionBullet);
            b.push(new Bullets(xBullet,yBullet,radiusBullet,directionBullet))
        }
        function newAsteroides(x,y,r,c){
            let d = Math.random() * 2 * Math.PI;
            a.push(new Asteroides(x-100,y-100,r-30,d,c))
            a.push(new Asteroides(x+100,y+100,r-30,-d,c))

        }
        //check colisions between asteroide and shot
        function checkCollisionShot(asteroide, bullet) {
        
        var dx = (asteroide.x + asteroide.R) - (bullet.x + bullet.r);
        var dy = (asteroide.y + asteroide.R) - (bullet.y + bullet.r);
        var distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < asteroide.R + bullet.r) {
            if(asteroide.R=="60"){
                points.innerHTML=+points.innerHTML+30
                setTimeout(newAsteroides(asteroide.x,asteroide.y,asteroide.R,asteroide.c),1000)
                
            }
            else{
                points.innerHTML=+points.innerHTML+15
            }
            b=b.filter(b=>b.x!=bullet.x);
            a=a.filter(a=>a.x!=asteroide.x)
        }
    }

        function checkCollisionsShot() {
            //percorre o array de inimigos 
            for (let i = 0; i < a.length; i++) {
                //percorre o array de balas 
                for (let j = 0; j <b.length; j++)
                checkCollisionShot(a[i], b[j])
            }
        }
	</script>
</body>
</html>